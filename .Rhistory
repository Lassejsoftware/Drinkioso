#
# 03-09-2018
#
# Script which checks for updates of user against a file in checkinHist
# This should be run from a bat file with a timer.
#
.libPaths("c:/R_libs")
path = "C:/Users/jqmt/Desktop/jens/drinkioso/"
setwd(path)
library(jsonlite)
library(plyr)
#
rm(list = ls())
# functions
source("extra/config.R")
source("extra/unpackCheckins.R")
source("extra/untappdAPI.R")
source("extra/checkForNewVenues.R")
source("extra/makeVenueNames.R")
#
# Rip from plyr without warnings.
row_match <- function (x, y, on = NULL)
{
if (is.null(on)) {
on <- intersect(names(x), names(y))
}
keys <- join.keys(x, y, on)
x[keys$x %in% keys$y, , drop = FALSE]
}
# API setup
method = "user/checkins/"
wTime = 5#2*60 # Wait time between api calls and calculations. Only 100 calls per hour is allowed.
#
users = dir("checkinHist/")
users = gsub(pattern = "\\.rds", replacement = "", x = users)
#
for (i in users){
print(i)
cHist = readRDS(paste0("checkinHist/",i,".rds"))
print("Getting checkins")
newCheckinsReturn = untappdAPI(method = method, param = i, query = list(limit = 50))
print("Done")
newCheckins = unpackCheckins(newCheckinsReturn)
#
temp = row_match(cHist, newCheckins )
if (dim(temp)[1] != dim(newCheckins)[1]){
if (dim(temp)[1] == 0){
dfLarge = newCheckins
S = 1
while (S == 1){
# Woah more than 50 new beers!
Sys.sleep(wTime)
max_id = newCheckinsReturn$response$pagination$max_id
olderChecksRet = untappdAPI(method = method, param = i, query = list(limit = 50, max_id = max_id))
olderChecks = unpackCheckins(olderChecksRet)
temp = row_match(cHist, olderChecks)
dfLarge = rbind(dfLarge,olderChecks)
if (dim(temp)[1] != 0){
cHist = rbind(cHist, dfLarge)
cHist = unique(cHist)
S = 0
}
}
} else {
# New Checkins!
cHist = rbind(cHist,newCheckins)
cHist = unique(cHist) # This is sloppy.
}
cHist = cHist[order(cHist$checkin_id, decreasing = T),]
saveRDS(cHist, file = paste0("checkinHist/",i,".rds") )
}
#
print("getting new venues")
checkForNewVenues(cHist)
}
checkForNewVenues(cHist)
View(cHist)
View(checkForNewVenues)
df =cHist
method = "venue/info/"
venuesOld = dir("venues/")
venuesNew = unique(makeVenueNames(df))
View(makeVenueNames)
View(cHist)
dat =df
sum(c("venue_id") %in% names(dat))
venuesNew = unique(makeVenueNames(df))
#
# 29-08-2018
#
# Spits out a dataframe with is, slug and name
#
makeVenueNames <- function(dat, na_rm = 1){
if (sum(c("venue_id") %in% names(dat)) != 1 ){
print("Input data frame does not have the required variables!")
return(NULL)
}
if (na_rm == 1){
dat = subset(dat, !is.na(dat$venue_id))
}
if (dim(dat)[1] == 0){
print("No venues found")
return()
}
out = data.frame(venue_id = dat$venue_id,
venue_slug = dat$venue_slug,
#name = paste0(dat$venue_slug,"_",dat$venue_id,".rds")
name = paste0(dat$venue_id,".rds")
)
return(out)
}
venuesNew = unique(makeVenueNames(df))
View(venuesNew)
venuesOld = dir("venues/")
venuesNew = subset(venuesNew, !(venuesNew$name %in% venuesOld) )
venuesNew
source("extra/config.R")
source("extra/unpackCheckins.R")
source("extra/untappdAPI.R")
source("extra/checkForNewVenues.R")
source("extra/makeVenueNames.R")
checkForNewVenues(cHist, wTime = 10)
#
rm(list = ls())
# functions
source("extra/config.R")
source("extra/unpackCheckins.R")
source("extra/untappdAPI.R")
source("extra/checkForNewVenues.R")
source("extra/makeVenueNames.R")
#
# Rip from plyr without warnings.
row_match <- function (x, y, on = NULL)
{
if (is.null(on)) {
on <- intersect(names(x), names(y))
}
keys <- join.keys(x, y, on)
x[keys$x %in% keys$y, , drop = FALSE]
}
# API setup
method = "user/checkins/"
wTime = 5#2*60 # Wait time between api calls and calculations. Only 100 calls per hour is allowed.
#
users = dir("checkinHist/")
users = gsub(pattern = "\\.rds", replacement = "", x = users)
#
for (i in users){
print(i)
cHist = readRDS(paste0("checkinHist/",i,".rds"))
print("Getting checkins")
newCheckinsReturn = untappdAPI(method = method, param = i, query = list(limit = 50))
print("Done")
newCheckins = unpackCheckins(newCheckinsReturn)
#
temp = row_match(cHist, newCheckins )
if (dim(temp)[1] != dim(newCheckins)[1]){
if (dim(temp)[1] == 0){
dfLarge = newCheckins
S = 1
while (S == 1){
# Woah more than 50 new beers!
Sys.sleep(wTime)
max_id = newCheckinsReturn$response$pagination$max_id
olderChecksRet = untappdAPI(method = method, param = i, query = list(limit = 50, max_id = max_id))
olderChecks = unpackCheckins(olderChecksRet)
temp = row_match(cHist, olderChecks)
dfLarge = rbind(dfLarge,olderChecks)
if (dim(temp)[1] != 0){
cHist = rbind(cHist, dfLarge)
cHist = unique(cHist)
S = 0
}
}
} else {
# New Checkins!
cHist = rbind(cHist,newCheckins)
cHist = unique(cHist) # This is sloppy.
}
cHist = cHist[order(cHist$checkin_id, decreasing = T),]
saveRDS(cHist, file = paste0("checkinHist/",i,".rds") )
}
#
print("getting new venues")
checkForNewVenues(cHist, wTime = 10)
}
testMapDat <- readRDS("C:/Users/jqmt/Desktop/jens/drinkioso/testMapDat.rds")
View(testMapDat)
setwd("C:/Users/jqmt/Desktop/jens/drinkioso/")
#
library("leaflet")
#library("data.table")
library("sp")
#library("rgdal")
#library("KernSmooth")
library("tidyr")
library(htmltools)
#
# Copenhagen attempt
#
source("scoring.R")
source("makedfVenue.R")
source("createMapV3.R")
cph = readRDS("maps/cph.rds")
score = makedfScore()
View(score)
#
mapList = createMap(score,cph, lambda = 650)
#
score = mapList$score
score$col = "blue"
score$col[score$val>0] = "green"
scoreExp = mapList$scoreExp
# Make labels
users = dir("checkinHist/")
users = gsub("\\..*", "", users)
team = ifelse(score$val>0, "Green", "Blue")
inds = which(names(score) %in% users)
drinker = c()
num = c()
for (i in 1:dim(score)[1]){
drinker[i] = names(which.max(score[i,inds]))
num[i] = max(score[i,inds])
}
label = paste0("<b> Venue: </b>", score$venue_name, " owned by team <b>", team,  "</b> <br/>",
"<b> Venue score is:  </b>", abs(score$val) , "<br/>",
"<b> Best team player: </b>", drinker, " with ", num, " beers!"
)
score$label = label
BREAKS = c(seq(-40,40,by=10),-5,5,1,1,-0.1,0.1)
CL <- contourLines(unique(scoreExp$x) , unique(scoreExp$y) , mapList$mapImage, levels = BREAKS)
## EXTRACT CONTOUR LINE LEVELS
LEVS <- as.factor(sapply(CL, `[[`, "level"))
NLEV <- length(levels(LEVS))
## CONVERT CONTOUR LINES TO POLYGONS
pgons <- lapply(1:length(CL), function(i)
Polygons(list(Polygon(cbind(CL[[i]]$x, CL[[i]]$y))), ID=i))
spgons = SpatialPolygons(pgons)
# With bars
leaflet(spgons) %>% addTiles() %>%
addPolygons(color = heat.colors(NLEV, NULL)[LEVS], fillOpacity = 0.5) %>%
addCircles(lng = score$lon, lat = score$lat,
radius = abs(score$val), opacity = 1, col = score$col, fillOpacity = 1, label = lapply(score$label,HTML),
labelOptions = list(textsize = "15px"))
View(mapList)
#
# 08-11-2018
#
# Make a leaflet map of cph with bars
#
# map is basically only for limiting georgraphy of bars.
#
createMap <- function(score, map, lambda = 650){
outList = list()
calcMap <- function(x, y, x0, y0, S, lambda){
# x,y: grid of map.
# x0,y0 vectors of bar coords.
# S bar score.
# lambda = decay const.
if (length(x0) != length(y0) | length(x0) != length(S)){
print("All bars should have a individual location and score")
return()
}
#
nx = length(x)
ny = length(y)
# generate grid
g = expand.grid(x = x, y = y)
temp = c(g$x)
xMat = matrix(data = temp, nrow = nx, ncol = ny)
temp = c(g$y)
yMat = matrix(data = temp, nrow = nx, ncol = ny)
#
scoreMat = matrix(data = 0, nrow = length(x), ncol = length(y))
for (i in 1:length(x0)){
rMat = sqrt((xMat - x0[i])^2 + (yMat - y0[i])^2)
scoreMat = scoreMat + S[i]*exp(-lambda*rMat)
}
return(scoreMat)
}
# Only include bars in Copenhagen.
lims = attr(map,"bb")
score = subset(score, score$lat>lims$ll.lat & score$lat<lims$ur.lat & score$lon>lims$ll.lon & score$lon<lims$ur.lon)
# Add team colours
score$col = "blue"
score$col[score$val>0] = "green"
# Make labels
users = dir("checkinHist/")
users = gsub("\\..*", "", users)
team = ifelse(score$val>0, "Green", "Blue")
inds = which(names(score) %in% users)
drinker = c()
num = c()
for (i in 1:dim(score)[1]){ # Make better solution please
drinker[i] = names(which.max(score[i,inds]))
num[i] = max(score[i,inds])
}
label = paste0("<b> Venue: </b>", score$venue_name, " owned by team <b>", team,  "</b> <br/>",
"<b> Venue score is:  </b>", abs(score$val) , "<br/>",
"<b> Best team player: </b>", drinker, " with ", num, " beers!"
)
score$label = label
outList$score = score
# make a map image
nx = 256
dx = abs(min(score$lon)- max(score$lon))
dy = abs(min(score$lat)- max(score$lat))
#
x = seq(min(score$lon)-0.75*dx, max(score$lon)+0.75*dx, length.out = nx)
y = seq(min(score$lat)-0.75*dy, max(score$lat)+0.75*dy, length.out = nx)
x0 = score$lon
y0 = score$lat
S = score$val
mapImage = calcMap(x=x,
y=y,
x0=x0,
y0=y0,
S=S,
lambda = lambda)
epsi = 0.05
mapImage[abs(mapImage)<epsi] = 0
outList$mapImage = mapImage
# Make smoothed score df
scoreExp <- expand.grid(x = x, y = y)
scoreExp$val <- as.vector(mapImage)
scoreExp <- na.omit(scoreExp)
outList$scoreExp <- scoreExp
return(outList)
}
test = createMap(score = score, map = cph)
names(test)
#
# run that drinkioso dashboard
#
# display.mode="showcase"
#
.libPaths("c:/R_libs")
library(shiny)
#
rm(list = ls())
runApp("C:/Users/jqmt/Desktop/jens/drinkioso/")
runApp("C:/Users/jqmt/Desktop/jens/drinkioso/")
runApp("C:/Users/jqmt/Desktop/jens/drinkioso/")
runApp("C:/Users/jqmt/Desktop/jens/drinkioso/")
runApp("C:/Users/jqmt/Desktop/jens/drinkioso/")
runApp("C:/Users/jqmt/Desktop/jens/drinkioso/")
runApp("C:/Users/jqmt/Desktop/jens/drinkioso/")
runApp("C:/Users/jqmt/Desktop/jens/drinkioso/")
runApp("C:/Users/jqmt/Desktop/jens/drinkioso/")
runApp("C:/Users/jqmt/Desktop/jens/drinkioso/")
runApp("C:/Users/jqmt/Desktop/jens/drinkioso/")
runApp("C:/Users/jqmt/Desktop/jens/drinkioso/")
runApp("C:/Users/jqmt/Desktop/jens/drinkioso/")
runApp("C:/Users/jqmt/Desktop/jens/drinkioso/")
View(makeVenueList)
runApp("C:/Users/jqmt/Desktop/jens/drinkioso/")
