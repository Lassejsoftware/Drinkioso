x = seq(min(score$lon), max(score$lon), length.out = nx)
y = seq(min(score$lat), max(score$lat), length.out = nx)
x0 = score$lon
y0 = score$lat
S = score$val
test = calcMap(x=x,
y=y,
x0=x0,
y0=y0
S=S,
lambda=0.1)
test = calcMap(x=x,
y=y,
x0=x0,
y0=y0,
S=S,
lambda=0.1)
View(calcMap)
calcMap <- function(x, y, x0, y0, S, lambda){
# x,y: grid of map.
# x0,y0 vectors of bar coords.
# S bar score.
# lambda = decay const.
if (length(x0) != length(y0) | length(x0) != length(S)){
print("All bars should have a individual location and score")
return()
}
#
nx = length(x)
ny = length(y)
# generate grid
g = expand.grid(x = x, y = y)
test = c(g$x,g$y)
xMat = matrix(data = test, nrow = nx, ncol = ny)
yMat = t(xMat)
#
scoreMat = matrix(data = 0, nrow = length(x), ncol = length(y))
for (i in 1:length(x0)){
rMat = sqrt((xMat - x0[i])^2 + (yMat - y0[i])^2)
if (S[i]>0){
scoreMat = scoreMat + floor(S[i]*exp(-lambda*rMat))
} else {
scoreMat = scoreMat + ceiling(S[i]*exp(-lambda*rMat))
}
}
return(scoreMat)
}
test = calcMap(x=x,
y=y,
x0=x0,
y0=y0,
S=S,
lambda=0.1)
image(test)
unique(test)
S
#
nx = length(x)
ny = length(y)
# generate grid
g = expand.grid(x = x, y = y)
test = c(g$x,g$y)
xMat = matrix(data = test, nrow = nx, ncol = ny)
yMat = t(xMat)
xMat[1]
mean(score$lon)
#
scoreMat = matrix(data = 0, nrow = length(x), ncol = length(y))
lambda=0.1
for (i in 1:length(x0)){
rMat = sqrt((xMat - x0[i])^2 + (yMat - y0[i])^2)
if (S[i]>0){
scoreMat = scoreMat + floor(S[i]*exp(-lambda*rMat))
} else {
scoreMat = scoreMat + ceiling(S[i]*exp(-lambda*rMat))
}
}
scoreMat
S
i=1
rMat = sqrt((xMat - x0[i])^2 + (yMat - y0[i])^2)
image(rMat)
x0[1]
y0[1]
min(x)
max(x)
min(y)
max(y)
View(xMat)
View(yMat)
rMat = sqrt((xMat)^2 + (yMat)^2)
image(rMat)
rMat = sqrt((xMat - x0)^2 + (yMat - y0)^2)
rMat = sqrt((xMat - x0[1])^2 + (yMat - y0[1])^2)
image(rMat)
View(rMat)
rMat = sqrt((xMat - x0[1])^2 + 0*(yMat - y0[1])^2)
image(rMat)
View(rMat)
min(xMAt)
min(xMat)
max(xMat)
x0[1]
min(abs(xMat - x0[1]))
min(rMat)
rMat = sqrt((xMat - x0[i])^2 + (yMat - y0[i])^2)
test = floor(S[i]*exp(-lambda*rMat))
S[i]
unique(test)
unique(rMat)
rMat = sqrt( 0*(xMat - x0[1])^2 + (yMat - y0[1])^2)
image(rMat)
max(yMay)
max(yMat)
y0[1]
# generate grid
g = expand.grid(x = x, y = y)
test = c(g$x,g$y)
64^64
642
64^2
View(g)
test = c(g$x,g$y)
xMat = matrix(data = test, nrow = nx, ncol = ny)
# generate grid
g = expand.grid(x = x, y = y)
test = c(g$x)
xMat = matrix(data = test, nrow = nx, ncol = ny)
temp = c(g$x)
xMat = matrix(data = temp, nrow = nx, ncol = ny)
temp = c(g$y)
yMat =matrix(data = temp, nrow = nx, ncol = ny)
rMat = sqrt((xMat - x0[i])^2 + (yMat - y0[i])^2)
image(rMat)
calcMap <- function(x, y, x0, y0, S, lambda){
# x,y: grid of map.
# x0,y0 vectors of bar coords.
# S bar score.
# lambda = decay const.
if (length(x0) != length(y0) | length(x0) != length(S)){
print("All bars should have a individual location and score")
return()
}
#
nx = length(x)
ny = length(y)
# generate grid
g = expand.grid(x = x, y = y)
temp = c(g$x)
xMat = matrix(data = temp, nrow = nx, ncol = ny)
temp = c(g$y)
yMat =matrix(data = temp, nrow = nx, ncol = ny)
#
scoreMat = matrix(data = 0, nrow = length(x), ncol = length(y))
for (i in 1:length(x0)){
rMat = sqrt((xMat - x0[i])^2 + (yMat - y0[i])^2)
if (S[i]>0){
scoreMat = scoreMat + floor(S[i]*exp(-lambda*rMat))
} else {
scoreMat = scoreMat + ceiling(S[i]*exp(-lambda*rMat))
}
}
return(scoreMat)
}
nx = 64
x = seq(min(score$lon), max(score$lon), length.out = nx)
y = seq(min(score$lat), max(score$lat), length.out = nx)
x0 = score$lon
y0 = score$lat
S = score$val
test = calcMap(x=x,
y=y,
x0=x0,
y0=y0,
S=S,
lambda=0.1)
image(test)
hist(test)
calcMap <- function(x, y, x0, y0, S, lambda){
# x,y: grid of map.
# x0,y0 vectors of bar coords.
# S bar score.
# lambda = decay const.
if (length(x0) != length(y0) | length(x0) != length(S)){
print("All bars should have a individual location and score")
return()
}
#
nx = length(x)
ny = length(y)
# generate grid
g = expand.grid(x = x, y = y)
temp = c(g$x)
xMat = matrix(data = temp, nrow = nx, ncol = ny)
temp = c(g$y)
yMat =matrix(data = temp, nrow = nx, ncol = ny)
#
scoreMat = matrix(data = 0, nrow = length(x), ncol = length(y))
for (i in 1:length(x0)){
rMat = sqrt((xMat - x0[i])^2 + (yMat - y0[i])^2)
if (S[i]>0){
scoreMat = scoreMat + floor(S[i]*exp(-lambda*rMat))
} else {
scoreMat = scoreMat + ceiling(S[i]*exp(-lambda*rMat))
}
}
return(scoreMat)
}
#
nx = length(x)
ny = length(y)
# generate grid
g = expand.grid(x = x, y = y)
temp = c(g$x)
xMat = matrix(data = temp, nrow = nx, ncol = ny)
temp = c(g$y)
yMat =matrix(data = temp, nrow = nx, ncol = ny)
yMat = t(yMat)
#
scoreMat = matrix(data = 0, nrow = length(x), ncol = length(y))
for (i in 1:length(x0)){
rMat = sqrt((xMat - x0[i])^2 + (yMat - y0[i])^2)
if (S[i]>0){
scoreMat = scoreMat + floor(S[i]*exp(-lambda*rMat))
} else {
scoreMat = scoreMat + ceiling(S[i]*exp(-lambda*rMat))
}
}
image(scoreMat)
length(x0)
S[110]
image(rMAt)
image(rMat)
S[100]
i=100
rMat = sqrt((xMat - x0[i])^2 + (yMat - y0[i])^2)
image(rMat)
yMat =matrix(data = temp, nrow = nx, ncol = ny)
rMat = sqrt((xMat - x0[i])^2 + (yMat - y0[i])^2)
image(rMat)
S[i]
test = floor(S[i]*exp(-lambda*rMat))
image(test)
unique(test)
S[i]
test = floor(S[i]*exp(-lambda*rMat/100))
unique(test)
unique(rMat)
min(rMat)
which.min
which.min(rMat)
lambda
exp(-lambda*0)
exp(-lambda*0)*s[i]
exp(-lambda*0)*S[i]
exp(-lambda*rMat[1501])*S[i]
max(rMat)
exp(-lambda*0.07)*S[i]
exp(-0.001*0.07)*S[i]
exp(-100*0.07)*S[i]
# make a map image
nx = 64
x = seq(min(score$lon), max(score$lon), length.out = nx)
y = seq(min(score$lat), max(score$lat), length.out = nx)
x0 = score$lon
y0 = score$lat
S = score$val
test = calcMap(x=x,
y=y,
x0=x0,
y0=y0,
S=S,
lambda=100)
unique(test)
image(test)
# Make smoothed score df
scoreExp <- expand.grid(x = x, y = y)
scoreExp$val <- as.vector(mapImage)
mapImage = calcMap(x=x,
y=y,
x0=x0,
y0=y0,
S=S,
lambda = 100)
scoreExp$val <- as.vector(mapImage)
scoreExp <- na.omit(scoreExp)
# Calculate contour lines
BREAKS = c(seq(from = 0.5*min(scoreExp$val), to = 0.5*max(scoreExp$val), length.out = 8),-0.01,0.01)
BREAKS = round(BREAKS*1000)/1000
# Make a map.
gg <- ggmap(map,
extent = "device", #
ylab = "Latitude",
xlab = "Longitude")
gg2 <- gg +
stat_contour(data = scoreExp, breaks = BREAKS,
aes(x=x,y=y,z=val, fill = factor(..level..)), geom = "polygon", alpha = alpha) +
scale_fill_viridis(discrete = T) +
geom_point(data = score,
aes(x = lon, y = lat, size = abs(val), color = sign(val)))
gg2
View(scoreExp)
BREAKS
max(scoreExp$val)
# Make a map.
gg <- ggmap(map,
extent = "device", #
ylab = "Latitude",
xlab = "Longitude")
gg2 <- gg +
stat_contour(data = scoreExp, #breaks = BREAKS,
aes(x=x,y=y,z=val, fill = factor(..level..)), geom = "polygon", alpha = alpha) +
scale_fill_viridis(discrete = T) +
geom_point(data = score,
aes(x = lon, y = lat, size = abs(val), color = sign(val)))
gg2
View(score)
View(scoreExp)
unique(scoreExp$val)
sort(unique(scoreExp$val))
#
rm(list = ls())
runApp("C:/Users/jqmt/Desktop/jens/drinkioso/")
View(tscoreExp)
getVenueCheckIn <- function(){
hists = dir("checkinHist/")
cc = 1
for (i in hists){
if (cc == 1){
tot = readRDS(paste0("checkinHist/",i))
cc = cc + 1
} else {
temp = readRDS(paste0("checkinHist/",i))
tot = rbind(tot,temp)
}
}
return(tot)
}
#
tot = getVenueCheckIn()
tot = subset(tot, !is.na(tot$venue_name))
temp = unique(tot[,c("venue_slug","venue_name")])
aggTot = aggregate(venue_slug ~ user_name + venue_name + venue_id, data = tot, length)
names(aggTot)[names(aggTot) == "venue_slug"] <- "count"
aggTot = merge(aggTot, temp, by = "venue_name", all.x = T)
spreadTot = spread(aggTot, key = user_name, value = count)
spreadTot[is.na(spreadTot)] = 0
#
dfVenue = makedfVenue()
spreadTot = merge(spreadTot,dfVenue, by = "venue_id", all.x = T)
#
score = na.omit(spreadTot)
names(score)[names(score) == "lng"] = "lon"
score$val = score$Garbacz + score$hellegskov- score$Slendrick - score$knoe1703 - score$camillask
#
# 14-09-2018
#
# Create map
#
createMap <- function(score, map, alpha = 0.5, sigma = 3){
outList = list()
# Only include locations on the map
lims = attr(map,"bb")
score = subset(score, score$lat>lims$ll.lat & score$lat<lims$ur.lat & score$lon>lims$ll.lon & score$lon<lims$ur.lon)
outList$score = score
# Extend a bit for reducing artifacts
epsi = 0.001
N = dim(score)[1]
score[N+1,c("lon","lat","val")] <- c(lims$ll.lon+epsi,lims$ll.lat+epsi,0)
score[N+2,c("lon","lat","val")] <- c(lims$ll.lon+epsi,lims$ur.lat-epsi,0)
score[N+3,c("lon","lat","val")] <- c(lims$ur.lon-epsi,lims$ll.lat+epsi,0)
score[N+4,c("lon","lat","val")] <- c(lims$ur.lon-epsi,lims$ur.lat-epsi,0)
# make a map image
nx = 64
x = seq(min(score$lon), max(score$lon), length.out = nx)
y = seq(min(score$lat), max(score$lat), length.out = nx)
x0 = score$lon
y0 = score$lat
S = score$val
mapImage = calcMap(x=x,
y=y,
x0=x0,
y0=y0,
S=S,
lambda = 100)
# Make smoothed score df
scoreExp <- expand.grid(x = x, y = y)
scoreExp$val <- as.vector(mapImage)
scoreExp <- na.omit(scoreExp)
# Calculate contour lines
# BREAKS = c(seq(from = 0.5*min(scoreExp$val), to = 0.5*max(scoreExp$val), length.out = 8),-0.01,0.01)
# BREAKS = round(BREAKS*1000)/1000
# Make a map.
gg <- ggmap(map,
extent = "device", #
ylab = "Latitude",
xlab = "Longitude")
gg2 <- gg +
stat_contour(data = scoreExp, #breaks = BREAKS,
aes(x=x,y=y,z=val, fill = factor(..level..)), geom = "polygon", alpha = alpha) +
scale_fill_viridis(discrete = T) +
geom_point(data = score,
aes(x = lon, y = lat, size = abs(val), color = sign(val)))
outList$plot <- gg2
return(outList)
}
map = createMap(score,cph)
#
# 14-09-2018
#
# Create map
#
createMap <- function(score, map, alpha = 0.5, sigma = 3){
outList = list()
calcMap <- function(x, y, x0, y0, S, lambda){
# x,y: grid of map.
# x0,y0 vectors of bar coords.
# S bar score.
# lambda = decay const.
if (length(x0) != length(y0) | length(x0) != length(S)){
print("All bars should have a individual location and score")
return()
}
#
nx = length(x)
ny = length(y)
# generate grid
g = expand.grid(x = x, y = y)
temp = c(g$x)
xMat = matrix(data = temp, nrow = nx, ncol = ny)
temp = c(g$y)
yMat = matrix(data = temp, nrow = nx, ncol = ny)
#
scoreMat = matrix(data = 0, nrow = length(x), ncol = length(y))
for (i in 1:length(x0)){
rMat = sqrt((xMat - x0[i])^2 + (yMat - y0[i])^2)
if (S[i]>0){
scoreMat = scoreMat + round(S[i]*exp(-lambda*rMat))
} else {
scoreMat = scoreMat + round(S[i]*exp(-lambda*rMat))
}
}
return(scoreMat)
}
# Only include locations on the map
lims = attr(map,"bb")
score = subset(score, score$lat>lims$ll.lat & score$lat<lims$ur.lat & score$lon>lims$ll.lon & score$lon<lims$ur.lon)
outList$score = score
# Extend a bit for reducing artifacts
epsi = 0.001
N = dim(score)[1]
score[N+1,c("lon","lat","val")] <- c(lims$ll.lon+epsi,lims$ll.lat+epsi,0)
score[N+2,c("lon","lat","val")] <- c(lims$ll.lon+epsi,lims$ur.lat-epsi,0)
score[N+3,c("lon","lat","val")] <- c(lims$ur.lon-epsi,lims$ll.lat+epsi,0)
score[N+4,c("lon","lat","val")] <- c(lims$ur.lon-epsi,lims$ur.lat-epsi,0)
# make a map image
nx = 64
x = seq(min(score$lon), max(score$lon), length.out = nx)
y = seq(min(score$lat), max(score$lat), length.out = nx)
x0 = score$lon
y0 = score$lat
S = score$val
mapImage = calcMap(x=x,
y=y,
x0=x0,
y0=y0,
S=S,
lambda = 100)
# Make smoothed score df
scoreExp <- expand.grid(x = x, y = y)
scoreExp$val <- as.vector(mapImage)
scoreExp <- na.omit(scoreExp)
# Calculate contour lines
# BREAKS = c(seq(from = 0.5*min(scoreExp$val), to = 0.5*max(scoreExp$val), length.out = 8),-0.01,0.01)
# BREAKS = round(BREAKS*1000)/1000
# Make a map.
gg <- ggmap(map,
extent = "device", #
ylab = "Latitude",
xlab = "Longitude")
gg2 <- gg +
stat_contour(data = scoreExp, #breaks = BREAKS,
aes(x=x,y=y,z=val, fill = factor(..level..)), geom = "polygon", alpha = alpha) +
scale_fill_viridis(discrete = T) +
geom_point(data = score,
aes(x = lon, y = lat, size = abs(val), color = sign(val)))
outList$plot <- gg2
return(outList)
}
map = createMap(score,cph)
map$plot
#
rm(list = ls())
runApp("C:/Users/jqmt/Desktop/jens/drinkioso/")
runApp("C:/Users/jqmt/Desktop/jens/drinkioso/")
# Calculate contour lines
BREAKS = c(seq(from = 0.5*min(scoreExp$val), to = 0.5*max(scoreExp$val), length.out = 8),-0.01,0.01)
scoreExp <- tscoreExp
# Calculate contour lines
BREAKS = c(seq(from = 0.5*min(scoreExp$val), to = 0.5*max(scoreExp$val), length.out = 8),-0.01,0.01)
BREAKS
BREAKS = seq(-50,50,by=5)
Breaks
BREAKS
runApp("C:/Users/jqmt/Desktop/jens/drinkioso/")
runApp("C:/Users/jqmt/Desktop/jens/drinkioso/")
runApp("C:/Users/jqmt/Desktop/jens/drinkioso/")
runApp("C:/Users/jqmt/Desktop/jens/drinkioso/")
runApp("C:/Users/jqmt/Desktop/jens/drinkioso/")
runApp("C:/Users/jqmt/Desktop/jens/drinkioso/")
runApp("C:/Users/jqmt/Desktop/jens/drinkioso/")
runApp("C:/Users/jqmt/Desktop/jens/drinkioso/")
